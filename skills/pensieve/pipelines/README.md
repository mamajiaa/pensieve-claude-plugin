# Pipelines（流程）

可执行的工作流程。定义从输入到验证的完整回路。

> 说明：Pensieve 内置工具已迁移到 `tools/` 目录；插件不再内置 pipelines。初始 pipeline 在安装/迁移时写入项目级 `.claude/pensieve/pipelines/`，用户可自由修改。

## 目的

Pipeline 存在的理由是**构建可验证的执行回路**。

Pipeline 不是步骤清单，而是符合大模型工作方式的闭环系统：

```
输入 → 执行 → 验证 → 输出
         ↑      ↓
         └──反馈──┘
```

### 好的 Pipeline 特征

| 特征 | 为什么重要（大模型视角） |
|------|--------------------------|
| **闭环** | 大模型容易发散，需要明确的起点和终点 |
| **实际指标** | 通过真实输出验证，不从代码推演 |
| **文件式日志** | 可追溯，出问题能定位到具体步骤 |
| **可测试** | 验证执行正确性，不靠"感觉" |
| **可工具化** | 识别可以用工具消除不确定性的环节 |

### 验证必须基于实际反馈

**反模式**：模型读代码 → "觉得"逻辑正确 → 继续

**正确方式**：执行代码 → 产生实际输出 → 读取输出 → 验证

| 验证类型 | 实际反馈来源 |
|----------|--------------|
| 编译/构建 | 编译器输出、构建日志 |
| 测试 | 测试运行结果、覆盖率报告 |
| 运行时 | 应用日志、错误堆栈 |
| 集成 | API 响应、数据库状态 |

**关键**：生产函数的实际反馈，而不是从代码中推演。系统不会骗你，模型推演会。

## 沉淀判断

问自己：**这个流程如果不固化，会重复决策什么？**

### 是否需要新增 Pipeline？

**先问**：能否通过编排现有 pipeline 的顺序解决？

| 情况 | 动作 |
|------|------|
| 现有 pipeline 组合能解决 | 编排顺序，不新增 |
| 缺少某个验证环节 | 补充到现有 pipeline |
| 完全不同的执行回路 | 新增 pipeline |

### 沉淀信号

| 信号 | 说明 |
|------|------|
| 多个 loop 的 tasks 结构相似 | 步骤顺序已稳定，可提炼 |
| 某类任务总是遗漏同一步 | 需要清单保证完整性 |
| 执行依赖多个 knowledge 的组合 | 需要 pipeline 串联知识 |

### 演进路径

```
先可达成（baseline）→ 再精细化（工具、编排优化）
```

1. **Baseline**：能跑通，有基本验证，哪怕手动
2. **工具化**：识别重复/易错环节，制作工具消除不确定性
3. **编排优化**：调整顺序减少回退，提高效率

**反模式**：一开始就追求完美的 pipeline，没跑过就优化。

## 关系与演化

| 方向 | 说明 |
|------|------|
| Pipeline ← Knowledge | 外部标准作为执行依据 |
| Pipeline → Tasks | Pipeline 定义回路，Tasks 是具体行动 |
| Pipeline ↔ Decision | 执行中形成的决策可能改进 pipeline |

### Pipeline vs Tasks

| 类型 | 本质 | 关注点 |
|------|------|--------|
| Pipeline | 执行回路 | "怎么验证"（闭环 + 指标） |
| Tasks | 具体行动 | "做什么"（当前步骤） |

Pipeline 定义回路，Tasks 是回路中的具体行动。

## 编写指南

### 目录结构

```
.claude/pensieve/pipelines/
├── {name}.md
```

### 命名约定

| 前缀 | 类型 | 说明 |
|------|------|------|
| `_` | 不建议 | 插件不再内置 pipeline |
| 无 | 用户定义 | 项目/业务相关流程，如 `review.md` |

### 文件格式

```markdown
# Pipeline 名称

---
description: 简要描述。当用户说"触发词1"、"触发词2"时触发。
---

角色定位：你是[做什么的]...

## 核心原则

- **原则1**: 说明
- **原则2**: 说明

---

## Phase 1: 阶段名

**目标**：这个阶段要达成什么

**行动**：
1. 具体动作
2. 具体动作

**验证**：[如何验证这一步完成]

---

## Phase 2: 阶段名

**目标**：这个阶段要达成什么

**CRITICAL**: 关键警告（如果有）

**行动**：
1. 具体动作
2. **向用户展示并等待确认**

---

## 相关文件

- `相关文件路径` — 说明
```

### 格式要点

| 元素 | 说明 |
|------|------|
| `description` | 在 frontmatter 中，包含触发词 |
| 角色定位 | 以“你是...”开头，明确 Claude 的角色 |
| 核心原则 | 3-5 条核心原则，前置 |
| Phase（而非 Step） | 每个阶段用 `---` 分隔 |
| **目标** | 每个 Phase 必须有目标 |
| **行动** | 编号列表，具体动作 |
| **CRITICAL** / **DO NOT SKIP** | 关键步骤的强标记 |
| 用户确认点 | 明确标注“等待确认” |

### 示例

```markdown
# 代码审查 Pipeline

---
description: 代码审查流程。当用户说"审查代码"、"review"、"帮我看看这个改动"时触发。
---

你正在进行系统性的代码审查，在彻底性与务实性之间平衡。

## 核心原则

- **证据驱动**：每个问题都要引用具体代码
- **严重性意识**：区分关键问题与细枝末节
- **可执行**：给出明确可落实的改进建议

---

## Phase 1: 理解变更

**目标**：完整理解变更内容

**行动**：
1. 阅读 diff 或指定提交
2. 列出所有修改的文件
3. 判断变更范围（单一功能/重构/修复等）

**验证**：能列出所有变更的文件和变更类型

---

## Phase 2: 系统化审查

**目标**：逐文件对照审查标准

**行动**：
1. 载入审查知识：`knowledge/taste-review/`
2. 对每个文件逐条检查
3. 记录结果：PASS / WARNING / CRITICAL

**CRITICAL**：每个 WARNING/CRITICAL 必须引用具体行号。

**验证**：每个检查项都有结论

---

## Phase 3: 报告

**目标**：输出可执行的审查结论

**行动**：
1. 按严重性汇总发现
2. 给出整体评估
3. **向用户呈现报告**

**验证**：报告包含所有发现和改进建议

---

## 相关文件

- `knowledge/taste-review/` — 审查标准与清单
```

## 注意事项

- Pipeline 必须**贴合项目实际** — 不存在通用最佳 pipeline
- 项目初期：pipeline 简单，验证宽松
- 项目成熟：pipeline 精细，验证严格
- 改进来自实际执行反馈，不凭空优化
