# Pensieve 架构

## 组件分工

| 组件 | 职责 |
|------|------|
| **Skill** | 知识库本身。定义五类数据结构，被 agent 引用 |
| **Agents** | 执行者。link-haiku（查询）、loop-planner（拆分任务）、self-improve（自改进） |
| **Hooks** | 触发器。Stop 时统计 task、捕获自改进机会 |
| **基础提示词** | 入口。告诉 Claude 使用 pensieve，加载 skill |
| **脚本** | 工具。统计自动化程度、同步关系 |

## 准则设计

准则只有一个文档，每一行是一条准则。从上到下的排序代表判断的顺序，遇到冲突时优先遵守排在前面的准则。

添加新准则时，需要考虑插入的位置，因为位置代表这条准则的能力边界。

### 准则的特征

准则是**品德**，不是技术细节：
- 跨项目：不依赖具体技术栈
- 跨问题：能指导未知的未来问题
- 超越性：抽象到可以应用于任何领域

编写准则时，self-improve agent 以**维特根斯坦**的视角审视：

- "语言的边界即思想的边界" — 准则必须精确，含混即无效
- "对于不可言说的，必须保持沉默" — 不沉淀无法清晰表达的规则
- "意义在于使用" — 准则的价值在于能否指导行动

### 准则自检

编写前自问，全部"是"才可沉淀为准则：

1. 无关项目？
2. 无关语言？
3. 无关领域？
4. 指导未来？
5. 可言说？

否则沉淀为 decision。

## Skill 与 Agent 的关系

Skill 是数据库。

主窗口负责调度，判断何时查询知识库、拆分任务、自改进。调用 agent 的时机写在 Skill 的 description 部分，作为热重载的提示词，一直携带在上下文窗口中。

## 两种模式

**非 Loop 模式**：正常和大模型对话。

**Loop 模式**：link-haiku 代替用户回答。

比如拆分任务前，主窗口询问 link-haiku 应该怎么做，link-haiku 根据冥想盆内容给出答案，然后才进行拆分任务。

## 进入 Loop 模式

- 用户明确说使用 loop
- 或主窗口主动询问用户（利用 Claude 的 AskUserQuestion 能力）

## Loop 状态文件位置

插件内 `skills/pensieve/loop/`

## Loop 目录结构

除了 task 列表，还需要一个目录包含：

- 做了什么
- 用户的需求是什么
- research 的文件索引
- 用户和模型的对话关键原始载体（方便回顾）
- 哪些直接干预（视作自改进的点）
- 基于哪些 decision、准则、pipeline

基于这些内容，才开始 task 拆分。

## 执行强化（Reinforcement）

每个 task 执行时注入强化信息，保持方向感：
- task 开始：整体目标 + 当前进度 + 准则
- task 失败：失败原因 + 修复提示
- task 完成：更新进度 + 下一个 task 预览

长对话中 agent 容易偏离目标，强化机制在关键点提醒整体目标和当前状态。

## self-improve 触发时机

- Loop 结束后，分析 loop 给出改进建议
- 用户也可以直接要求使用 agent 进行自改进

## 执行流程

```
用户输入
    ↓
基础提示词（加载 skill）
    ↓
Hook 捕获信号
    ↓
Agent 执行（link-haiku 查询 / loop-planner 拆分）
    ↓
Loop 执行 tasks
    ↓
Hook 统计完成情况
    ↓
self-improve 判断是否沉淀为规则
```
